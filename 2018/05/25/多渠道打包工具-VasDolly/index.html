<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android," />










<meta name="description" content="如何产生这种需求XXAPP目前的打包方式是通过Android Gradle Plugin去实现: 首先，在AndroidManifest.xml中添加渠道信息占位符 123&amp;lt;meta-data            android:name=&amp;quot;UMENG_CHANNEL&amp;quot;            android:value=&amp;quot;$&amp;#123;UMENG_CHANNE">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="多渠道打包工具-VasDolly">
<meta property="og:url" content="http://xuyangyang.top/2018/05/25/多渠道打包工具-VasDolly/index.html">
<meta property="og:site_name" content="MuFeiXue`s Blog">
<meta property="og:description" content="如何产生这种需求XXAPP目前的打包方式是通过Android Gradle Plugin去实现: 首先，在AndroidManifest.xml中添加渠道信息占位符 123&amp;lt;meta-data            android:name=&amp;quot;UMENG_CHANNEL&amp;quot;            android:value=&amp;quot;$&amp;#123;UMENG_CHANNE">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234009060-d3hhcGst57uT5p6E5Zu-LnBuZw==.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234066897-YXBrLXN0cnVjdHVyZS5qcGc=.jpg">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234134085-NzAxODAyMi01NmUyZWEyNGVkOTEyNDdmLmpwZw==.jpg">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234190519-d3hhcGstbGliLnBuZw==.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234224715-d3hhcGstTUVUQS1JTkYucG5n.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234248597-NzAxODAyMi1jMzg4ODA5OWJhZjkyN2I0LmpwZw==.jpg">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234279057-LmRleOeahOe7k-aehC5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234304724-NzAxODAyMi1mN2VjZDUyYWFkMzUzMDA0LmpwZw==.jpg">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234343028-d3hhcGstcmVzb3VyY2VzLnBuZw==.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234380993-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjI1NDUzNjI1MzkzNTI1NDIzMDI1NDUzNjI1Mzg0NDI1NDE0NTI1NDUzNTI1Mzg0MTI1NDEzMDI1NDUzNTI1NDE0NjI1MzgzNjI1NDUzNTI1MzkzMjI1Mzg0MzI1NDUzNjI1NDEzMDI1NDEzMTI1NDUzOTI1NDE0MTI1Mzg0MzI1NDUzNjI1NC5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234412736-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjRkNDE0ZTQ5NDY0NTUzNTQyZTRkNDYyZTcwNmU2Ny5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234429642-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjQzNDU1MjU0MmU1MzQ2MmU3MDZlNjcucG5n.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234495190-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU2MzEyNTQ1MzcyNTQxNDQyNTQyNDUyNTQ1MzUyNTM5MzAyNTM4NDQyNTQ1MzYyNTQyMzUyNTM4MzEyNTQ1MzcyNTQxMzgyNTM4NDIyZTcwNmU2Ny5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234521645-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU2MzEyNTQ1MzYyNTQxMzAyNTQxMzEyNTQ1MzkyNTQxNDEyNTM4NDMyNTQ1MzYyNTQyMzUyNTM4MzEyNTQ1MzcyNTQxMzgyNTM4NDIyZTcwNmU2Ny5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234550495-YXBrLXZhbGlkYXRpb24tcHJvY2Vzcy5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234613182-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU2MzIyNTQ1MzcyNTQxNDQyNTQyNDUyNTQ1MzUyNTM5MzAyNTM4NDQyNTQ1MzUyNTM5MzAyNTM4NDUyNTQ1MzcyNTM5NDEyNTM4MzQ0MTUwNGIyZTcwNmU2Ny5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234613182-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU2MzIyNTQ1MzcyNTQxNDQyNTQyNDUyNTQ1MzUyNTM5MzAyNTM4NDQyNTQ1MzUyNTM5MzAyNTM4NDUyNTQ1MzcyNTM5NDEyNTM4MzQ0MTUwNGIyZTcwNmU2Ny5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234697567-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU2MzIyNTQ1MzcyNTQxNDQyNTQyNDUyNTQ1MzUyNTM5MzAyNTM4NDQyNTQ1MzUyNTM5NDQyNTM5MzcyNTQ1MzcyNTM5MzQyNTM5NDYyNTQ1MzYyNTM4MzgyNTM5MzAyNTQ1MzYyNTQyMzUyNTM4MzEyNTQ1MzcyNTQxMzgyNTM4NDIyZS5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234722431-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjc2MzIyNTQ1MzcyNTQxNDQyNTQyNDUyNTQ1MzUyNTM5MzAyNTM4NDQyNTQ1MzUyNTM5NDQyNTM5MzcyNTQ1MzcyNTQyNDIyNTM5MzMyNTQ1MzYyNTM5NDUyNTM4MzQyZTcwNmU2Ny5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234748668-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU2MzIyNTQ1MzYyNTM5MzUyNTQyMzAyNTQ1MzYyNTM4NDQyNTQxNDUyNTQ1MzYyNTM5MzEyNTM5MzgyNTQ1MzgyNTQxMzYyNTM4MzEyNTQ1MzcyNTQxNDUyNTM5MzcyNTQ1MzYyNTQyMzMyNTM5MzUyZTcwNmU2Ny5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234767461-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU4MmQ0MTZlNjQ3MjZmNjk2NDJkNDE1MDRiMmQ1MzY5Njc2ZTY1NjQyZTcwNmU2Ny5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234786132-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjI1NDUzNjI1NDEzMDI1NDEzMTI1NDUzOTI1NDE0MTI1Mzg0MzI1NDUzOTI1MzgzMDI1MzgzOTI1NDUzNjI1Mzg0MjI1NDEzOTJlNzA2ZTY3LnBuZw==.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234804343-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjc2MzIyNTQ1MzYyNTQxMzAyNTQxMzEyNTQ1MzkyNTQxNDEyNTM4NDMyNTQ1MzYyNTQyMzUyNTM4MzEyNTQ1MzcyNTQxMzgyNTM4NDIyZTcwNmU2Ny5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234831308-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjQxNTA0YjI1NDUzNjI1MzkzNjI1MzgzNzI1NDUzNDI1NDI0MjI1NDIzNjI1NDUzNzI1NDI0MjI1MzkzMzI1NDUzNjI1Mzk0NTI1MzgzNDJlNzA2ZTY3LnBuZw==.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234850973-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjQ1NGY0MzQ0MmU3MDZlNjcucG5n.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234870776-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjI1NDUzNjI1NDIzNzI1NDI0MjI1NDUzNTI1Mzg0MTI1NDEzMDI1NDUzNjI1NDIzODI1NDEzMDI1NDUzOTI1MzgzMTI1MzkzMzI1NDUzNDI1NDI0NjI1NDEzMTI1NDUzNjI1MzgzMTI1NDE0NjI1NDUzNTI1MzkzMDI1Mzg0NTI1NDUzNzI1My5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234891952-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjI1NDUzNjI1NDIzNzI1NDI0MjI1NDUzNTI1Mzg0MTI1NDEzMDI1NDUzNjI1NDIzODI1NDEzMDI1NDUzOTI1MzgzMTI1MzkzMzI1NDUzNTI1MzkzMDI1Mzg0NTI1NDUzNzI1Mzk0MTI1MzgzNDQxNTA0YjJkNTYzMTJkNmU2NTc3MmU3MDZlNi5wbmc=.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234914283-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjI1NDUzNzI1NDEzMTI1NDE0NTI1NDUzNTI1NDE0NTI1Mzk0MTQ1NGY0MzQ0MjU0NTM3MjUzOTQxMjUzODM0MjU0NTM0MjU0MjQ0MjUzODQ0MjU0NTM3MjU0MjQ0MjU0MTQ1MmU3MDZlNjcucG5n.png">
<meta property="og:image" content="https://ojlty2hua.qnssl.com/image-1527234942589-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjI1NDUzNjI1NDIzNzI1NDI0MjI1NDUzNTI1Mzg0MTI1NDEzMDI1NDUzNjI1NDIzODI1NDEzMDI1NDUzOTI1MzgzMTI1MzkzMzI1NDUzNTI1MzkzMDI1Mzg0NTI1NDUzNzI1Mzk0MTI1MzgzNDQxNTA0YjJkNTYzMjJlNzA2ZTY3LnBuZw==.png">
<meta property="og:updated_time" content="2018-05-28T09:21:14.648Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多渠道打包工具-VasDolly">
<meta name="twitter:description" content="如何产生这种需求XXAPP目前的打包方式是通过Android Gradle Plugin去实现: 首先，在AndroidManifest.xml中添加渠道信息占位符 123&amp;lt;meta-data            android:name=&amp;quot;UMENG_CHANNEL&amp;quot;            android:value=&amp;quot;$&amp;#123;UMENG_CHANNE">
<meta name="twitter:image" content="https://ojlty2hua.qnssl.com/image-1527234009060-d3hhcGst57uT5p6E5Zu-LnBuZw==.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://xuyangyang.top/2018/05/25/多渠道打包工具-VasDolly/"/>





  <title>多渠道打包工具-VasDolly | MuFeiXue`s Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MuFeiXue`s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xuyangyang.top/2018/05/25/多渠道打包工具-VasDolly/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MuFeiXue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MuFeiXue`s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">多渠道打包工具-VasDolly</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-25T16:00:35+08:00">
                2018-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="如何产生这种需求"><a href="#如何产生这种需求" class="headerlink" title="如何产生这种需求"></a>如何产生这种需求</h2><p>XXAPP目前的打包方式是通过Android Gradle Plugin去实现:</p>
<p>首先，在AndroidManifest.xml中添加渠道信息占位符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line">            android:name=&quot;UMENG_CHANNEL&quot;</span><br><span class="line">            android:value=&quot;$&#123;UMENG_CHANNEL_VALUE&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>然后，通过Gradle Plugin的<code>productFlavors</code>标签，添加渠道信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions &quot;default&quot;</span><br><span class="line"></span><br><span class="line">productFlavors &#123;</span><br><span class="line"></span><br><span class="line">    myapp &#123;</span><br><span class="line">        dimension &quot;default&quot;</span><br><span class="line">        manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;360&quot;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    baidu &#123;</span><br><span class="line">        dimension &quot;default&quot;</span><br><span class="line">        manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;baidu&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，Gradle编译生成多渠道包时，会用不同的渠道信息替换AndroidManifest.xml中的占位符。我们在代码中，也就可以直接读取AndroidManifest.xml中的渠道信息了。</p>
<p><strong>但是这样的话，每生成一个渠道包，都要重新执行一遍构建流程，目前XXAPP渠道在26个左右，大概需要一个半小时，而且这打渠道包中间电脑很卡，几乎干不了其他的事情，所以这种需求就产生了</strong>。</p>
<a id="more"></a>                                                                                                                                                  
<h2 id="了解Android安装包-APK-的构成"><a href="#了解Android安装包-APK-的构成" class="headerlink" title="了解Android安装包(.APK)的构成"></a>了解Android安装包(.APK)的构成</h2><h3 id="apk是什么"><a href="#apk是什么" class="headerlink" title="apk是什么"></a>apk是什么</h3><p>​      APK是类似Symbian Sis或Sisx的文件格式，APK文件和Sis一样最终被android sdk编译的工具打包成一个为apk的安装程序文件格式，apk文件其实是zip格式，只是后缀名被修改为apk，其中包含Dex文件，Dex是Dalvik VM executes的全称，即Android Dalvik执行程序，并非Java ME的字节码而是Dalvik字节码。</p>
<h3 id="apk的结构"><a href="#apk的结构" class="headerlink" title="apk的结构"></a>apk的结构</h3><p>下图为微信最新版6.6.6APK解压目录</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234009060-d3hhcGst57uT5p6E5Zu-LnBuZw==.png" alt="wxapk-结构图"></p>
<p>主要包括:</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234066897-YXBrLXN0cnVjdHVyZS5qcGc=.jpg" alt="apk-structure"></p>
<p><strong>其中微信解压目录中没有res目录是因为微信用到了自己开源的<a href="https://github.com/shwenzhang/AndResGuard" target="_blank" rel="noopener">AndResGuard</a>混淆框架,如需了解<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=208135658&amp;idx=1&amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd" target="_blank" rel="noopener">AndResGuard原理</a></strong></p>
<p><strong>1)       assets目录</strong></p>
<p>​          用于存放需要打包到APK中的静态文件，和res的不同点在于，assets目录支持任意深度的子目录，用户可以根据自己的需求任意部署文件夹架构，而且res目录下的文件会在.R文件中生成对应的资源ID，assets不会自动生成对应的ID，访问的时候需要AssetManager类</p>
<p><strong>2)       lib目录</strong></p>
<p>​         这里存放应用程序依赖的native库文件，一般是用C/C++编写，这里的lib库可能包含4中不同类型，根据CPU型号的不同，大体可以分为ARM，ARM-v7a，MIPS，X86，分别对应着ARM架构，ARM-V7架构，MIPS架构和X86架构，这些so库在APK包中的构成如下图:</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234134085-NzAxODAyMi01NmUyZWEyNGVkOTEyNDdmLmpwZw==.jpg" alt="7018022-56e2ea24ed91247f"></p>
<p>下图为微信的lib截图:</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234190519-d3hhcGstbGliLnBuZw==.png" alt="wxapk-lib"></p>
<p>其中，不同的CPU架构对应着不同的目录，每个目录中可以放很多对应版本的so库，且这个目录的结构固定，用户只能按照这个目录存放自己的so库。目前市场上使用的移动终端大多是基于ARM或者ARM-V7a架构的，X86和MIPS架构的移动智能终端比较少，所以有些应用程序lib目录下只包含armeabi目录或者armeabi-v7a目录，也就是说，这四个目录要根据CPU的架构来选，而市面上ARM架构的手机占大多数，所以一般的APK只包含ARM和ARM-V7a的so</p>
<p><strong>3)       res目录</strong></p>
<p>​        res是resource的缩写，这个目录存放资源文件，存在这个文件夹下的所有文件都会映射到Android工程的.R文件中，生成对应的ID，访问的时候直接使用资源ID即<code>R.id.filename</code>，res文件夹下可以包含多个文件夹，其中anim存放动画文件；drawable目录存放图像资源；layout目录存放布局文件；values目录存放一些特征值，<code>colors.xml</code>存放color颜色值，<code>dimens.xml</code>定义尺寸值，<code>string.xml</code>定义字符串的值，<code>styles.xml</code>定义样式对象；xml文件夹存放任意xml文件，在运行时可以通过<code>Resources.getXML()</code>读取；raw是可以直接复制到设备中的任意文件，他们无需编译。</p>
<p><strong>4)       META-INF目录</strong></p>
<p>​         保存应用的签名信息，签名信息可以验证APK文件的完整性。AndroidSDK在打包APK时会计算APK包中所有文件的完整性，并且把这些完整性保存到META-INF文件夹下，应用程序在安装的时候首先会根据META-INF文件夹校验APK的完整性，这样就可以保证APK中的每一个文件都不能被篡改。以此来确保APK应用程序不被恶意修改或者病毒感染，有利于确保Android应用的完整性和系统的安全性。META-INF目录下包含的文件有<code>CERT.RSA</code>，<code>CERT.SF</code>和<code>MANIFEST.MF</code>，其中<code>CERT.RSA</code>是开发者利用私钥对APK进行签名的签名文件，<code>CERT.SF</code>，<code>MANIFEST.MF</code>记录了文件中文件的SHA-1哈希值 .SF文件里保存的是MANIFEST.MF文件的SHA1-Base64的值和除META-INF外所有文件的SHA1摘要Base64值的SHA1摘要Base64值。具体细节请点击<a href="https://blog.csdn.net/lostinai/article/details/54694564" target="_blank" rel="noopener">这里</a> </p>
<p>下图为微信的META-INF目录:</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234224715-d3hhcGstTUVUQS1JTkYucG5n.png" alt="wxapk-META-INF"></p>
<p><strong>5)       AndroidManifest.xml</strong></p>
<p>​              Android应用程序的配置文件，是一个用来描述Android应用“整体资讯”的设定文件，简单来说，相当于Android应用向Android系统“自我介绍”的配置文件，Android系统可以根据这个“自我介绍”完整地了解APK应用程序的资讯，每个Android应用程序都必须包含一个AndroidManifest.xml文件，且它的名字是固定的，不能修改。我们在开发Android应用程序的时候，一般都把代码中的每一个<code>Activity</code>，<code>Service</code>，<code>Provider</code>和<code>Receiver</code>在AndroidManifest.xml中注册，只有这样系统才能启动对应的组件，另外这个文件还包含一些权限声明以及使用的SDK版本信息等等。程序打包时，会把AndroidManifest.xml进行简单的编译，便于Android系统识别，编译之后的格式是AXML格式，如下图</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234248597-NzAxODAyMi1jMzg4ODA5OWJhZjkyN2I0LmpwZw==.jpg" alt="7018022-c3888099baf927b4"></p>
<p>AXML格式</p>
<p>axml头：其中的axml头是固定标识axml文件的，其值固定时0x00080003。</p>
<p>axml文件长度：标识axml文件的大小。</p>
<p>StringDataSegment：xml文件中所有字符串类型保存在此。</p>
<p>ResourceIdSegment：xml文件中声明的资源文件ID保存于此。</p>
<p>XmlContentSegment：是xml的内容段，按照xml文件中的结构依次排开，保存xml的数据内容。</p>
<p><strong>6)       classes.dex</strong></p>
<p>​    Dex结构如下所示:</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234279057-LmRleOeahOe7k-aehC5wbmc=.png" alt="dex的结构"></p>
<p>​        </p>
<p>​       传统的Java程序，首先先把Java文件编译成class文件，字节码都保存在了class文件中，Java虚拟机可以通过解释执行这些class文件。而Dalvik虚拟机是在Java虚拟机进行了优化，执行的是Dalvik字节码，而这些Dalvik字节码是由Java字节码转换而来，一般情况下，Android应用在打包时通过AndroidSDK中的dx工具将Java字节码转换为Dalvik字节码。dx工具可以对多个class文件进行合并，重组，优化，可以达到减小体积，缩短运行时间的目的。</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234304724-NzAxODAyMi1mN2VjZDUyYWFkMzUzMDA0LmpwZw==.jpg" alt="7018022-f7ecd52aad353004"></p>
<p>​     </p>
<p>dx工具把.class文件转换成dex文件</p>
<p>如图，dx工具把每个.class文件的每个区域的内容进行去重，重组，优化重排后生成dex文件，生成的dex文件可以在Dalvik虚拟机执行，且速度比较快。</p>
<p><strong>7)       resources.arsc</strong></p>
<p>​          用来记录资源文件和资源ID之间的映射关系，用来根据资源ID寻找资源。Android的开发是分模块的，res目录专门用来存放资源文件，当在代码中需要调用资源文件时，只需要调用<code>findviewbyId()</code>就可以得到资源文件，每当在res文件夹下放一个文件，aapt就会自动生成对应的ID保存在.R文件，我们调用这个ID就可以，但是只有这个ID还不够，.R文件只是保证编译程序不报错，实际上在程序运行时，系统要根据ID去寻找对应的资源路径，而resources.arsc文件就是用来记录这些ID和资源文件位置对应关系的文件。</p>
<p>下图为微信resources.arsc的部分映射图：</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234343028-d3hhcGstcmVzb3VyY2VzLnBuZw==.png" alt="wxapk-resources"></p>
<p>​                                                                                                               </p>
<h2 id="了解数据摘要、数字签名和数字证书"><a href="#了解数据摘要、数字签名和数字证书" class="headerlink" title="了解数据摘要、数字签名和数字证书"></a>了解数据摘要、数字签名和数字证书</h2><p>在进一步学习V1和V2签名之前，我们有必要学习一下签名相关的基础知识。 </p>
<h3 id="数据摘要"><a href="#数据摘要" class="headerlink" title="数据摘要"></a>数据摘要</h3><p>数据摘要算法是一种能产生特定输出格式的算法，其原理是根据一定的运算规则对原始数据进行某种形式的信息提取，被提取出的信息就是原始数据的消息摘要，也称为数据指纹。 一般情况下，数据摘要算法具有以下特点：</p>
<ol>
<li>无论输入数据有多大（长），计算出来的数据摘要的长度总是固定的。例如：MD5算法计算出的数据摘要有128Bit。</li>
<li>一般情况下（不考虑碰撞的情况下），只要原始数据不同，那么其对应的数据摘要就不会相同。同时，只要原始数据有任何改动，那么其数据摘要也会完全不同。即：相同的原始数据必有相同的数据摘要，不同的原始数据，其数据摘要也必然不同。</li>
<li>不可逆性，即只能正向提取原始数据的数据摘要，而无法从数据摘要中恢复出原始数据。</li>
</ol>
<p>著名的摘要算法有RSA公司的MD5算法和SHA系列算法。</p>
<h3 id="数字签名和数字证书"><a href="#数字签名和数字证书" class="headerlink" title="数字签名和数字证书"></a>数字签名和数字证书</h3><p>数字签名和数字证书是成对出现的，两者不可分离（<strong>数字签名主要用来校验数据的完整性，数字证书主要用来确保公钥的安全发放</strong>）。 </p>
<p>要明白数字签名的概念，必须要了解数据的加密、传输和校验流程。一般情况下，要实现数据的可靠通信，需要解决以下两个问题：</p>
<ol>
<li>确定数据的来源是其真正的发送者。</li>
<li>确保数据在传输过程中，没有被篡改，或者若被篡改了，可以及时发现。</li>
</ol>
<p>而数字签名，就是为了解决这两个问题而诞生的。 首先，数据的发送者需要先申请一对公私钥对，并将公钥交给数据接收者。 然后，若数据发送者需要发送数据给接收者，则首先要根据原始数据，生成一份数字签名，然后把原始数据和数字签名一起发送给接收者。 数字签名由以下两步计算得来：</p>
<ol>
<li>计算发送数据的数据摘要</li>
<li>用私钥对提取的数据摘要进行加密</li>
</ol>
<hr>
<p>这样，数据接收者拿到的消息就包含了两块内容：</p>
<ol>
<li>原始数据内容</li>
<li>附加的数字签名</li>
</ol>
<p>接下来，接收者就会通过以下几步，校验数据的真实性：</p>
<ol>
<li>用相同的摘要算法计算出原始数据的数据摘要。</li>
<li>用预先得到的公钥解密数字签名。</li>
<li>对比签名得到的数据是否一致，如果一致，则说明数据没有被篡改，否则数据就是脏数据了。</li>
</ol>
<p>因为私钥只有发送者才有，所以其他人无法伪造数字签名。这样通过数字签名就确保了数据的可靠传输。 综上所述，数字签名就是<strong><em>只有发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对发送者发送数据真实性的一个有效证明</em></strong>。</p>
<p>想法虽好，但是上面的整个流程，有一个前提，就是数据接收者能够正确拿到发送者的公钥。如果接收者拿到的公钥被篡改了，那么坏人就会被当成好人，而真正的数据发送者发送的数据则会被视作脏数据。那怎么才能保证公钥的安全性那？这就要靠数字证书来解决了。</p>
<p>数字证书是由有公信力的证书中心（CA）颁发给申请者的证书，主要包含了：证书的发布机构、证书的有效期、申请者的公钥、申请者信息、数字签名使用的算法，以及证书内容的数字签名。</p>
<p>可见，数字证书也用到了数字签名技术。只不过签名的内容是数据发送方的公钥，以及一些其它证书信息。 这样数据发送者发送的消息就包含了三部分内容：</p>
<ol>
<li>原始数据内容</li>
<li>附加的数字签名</li>
<li>申请的数字证书。</li>
</ol>
<p>接收者拿到数据后，首先会根据CA的公钥，解码出发送者的公钥。然后就与上面的校验流程完全相同了。</p>
<p>所以，<strong>数字证书主要解决了公钥的安全发放问题</strong>。 因此，包含数字证书的整个签名和校验流程如下图所示： </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234380993-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjI1NDUzNjI1MzkzNTI1NDIzMDI1NDUzNjI1Mzg0NDI1NDE0NTI1NDUzNTI1Mzg0MTI1NDEzMDI1NDUzNTI1NDE0NjI1MzgzNjI1NDUzNTI1MzkzMjI1Mzg0MzI1NDUzNjI1NDEzMDI1NDEzMTI1NDUzOTI1NDE0MTI1Mzg0MzI1NDUzNjI1NC5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f254536253935254230254536253844254145254535253841254130254535254146253836254535253932253843254536254130254131254539254141253843254536254"></p>
<p>​                                                                                                                                                     <strong>来源于</strong><a href="https://github.com/Tencent/VasDolly/wiki/VasDolly%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">VasDolly</a></p>
<h2 id="了解V1和V2"><a href="#了解V1和V2" class="headerlink" title="了解V1和V2"></a>了解V1和V2</h2><h3 id="APK-签名方案"><a href="#APK-签名方案" class="headerlink" title="APK 签名方案"></a>APK 签名方案</h3><h4 id="JAR-签名（v1-方案）"><a href="#JAR-签名（v1-方案）" class="headerlink" title="JAR 签名（v1 方案）"></a>JAR 签名（v1 方案）</h4><p>​        从一开始，APK 签名就是 Android 的一个有机部分。该方案基于<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Signed_JAR_File" target="_blank" rel="noopener">签名的 JAR</a>。如要详细了解如何使用该方案，请参阅介绍如何<a href="https://developer.android.com/studio/publish/app-signing.html" target="_blank" rel="noopener">为您的应用签名</a>的 Android Studio 文档。</p>
<p>v1 签名不保护 APK 的某些部分，例如 ZIP 元数据。APK 验证程序需要处理大量不可信（尚未经过验证）的数据结构，然后会舍弃不受签名保护的数据。这会导致相当大的受攻击面。此外，APK 验证程序必须解压所有已压缩的条目，而这需要花费更多时间和内存。为了解决这些问题，Android 7.0 中引入了 APK 签名方案 v2。 </p>
<h5 id="V1签名机制"><a href="#V1签名机制" class="headerlink" title="V1签名机制"></a>V1签名机制</h5><p>默认情况下，APK使用的就是V1签名。解压APK后，在<code>META-INF</code>目录下，可以看到三个文件：<code>MANIFEST.MF</code>、<code>CERT.SF</code>、<code>CERT.RSA</code>。它们都是V1签名的产物。 </p>
<p>其中，<code>MANIFEST.MF</code>文件内容如下所示： </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234412736-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjRkNDE0ZTQ5NDY0NTUzNTQyZTRkNDYyZTcwNmU2Ny5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f4d414e49464553542e4d462e706e67"></p>
<p>它记录了APK中所有原始文件的数据摘要的Base64编码,而数据摘要算法就是<code>SHA1</code>。</p>
<p><code>CERT.SF</code>文件内容如下所示：</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234429642-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjQzNDU1MjU0MmU1MzQ2MmU3MDZlNjcucG5n.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f434552542e53462e706e67"></p>
<p><code>SHA1-Digest-Manifest-Main-Attributes</code>主属性记录了<code>MANIFEST.MF</code>文件所有主属性的数据摘要的Base64编码。<code>SHA1-Digest-Manifest</code>则记录了整个<code>MANIFEST.MF</code>文件的数据摘要的Base64编码。 其余的普通属性则和<code>MANIFEST.MF</code>中的属性一一对应，分别记录了对应数据块的数据摘要的Base64编码。例如：<code>CERT.SF</code>文件中skin_drawable_btm_line.xml 对应的SHA1-Digest，就是下面内容的数据摘要的Base64编码。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name: res/drawable/skin_drawable_btm_line.xml</span><br><span class="line">SHA1-Digest: JqJbk6/AsWZMcGVehCXb33Cdtrk=</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<p>这里要注意的是：<strong>最后一行的换行符是必不可少，需要参与计算的</strong>。 </p>
<p><code>CERT.RSA</code>文件包含了对<code>CERT.SF</code>文件的数字签名和开发者的数字证书。<code>RSA</code>就是计算数字签名使用的非对称加密算法。</p>
<p>V1签名的详细流程可参考<a href="https://android.googlesource.com/platform/build/+/7e447ed/tools/signapk/SignApk.java" target="_blank" rel="noopener">SignApk.java</a>，整个签名流程如下图所示：</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234495190-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU2MzEyNTQ1MzcyNTQxNDQyNTQyNDUyNTQ1MzUyNTM5MzAyNTM4NDQyNTQ1MzYyNTQyMzUyNTM4MzEyNTQ1MzcyNTQxMzgyNTM4NDIyZTcwNmU2Ny5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f56312545372541442542452545352539302538442545362542352538312545372541382538422e706e67"></p>
<p>整个签名机制的最终产物就是MANIFEST.MF、CERT.SF、CERT.RSA三个文件。 </p>
<h5 id="V1校验流程"><a href="#V1校验流程" class="headerlink" title="V1校验流程"></a>V1校验流程</h5><p>在安装APK时，Android系统会校验签名，检查APK是否被篡改。代码流程是：<code>PackageManagerService.java</code> -&gt; <code>PackageParser.java</code>，<code>PackageParser</code>类负责V1签名的具体校验。整个校验流程如下图所示： </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234521645-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU2MzEyNTQ1MzYyNTQxMzAyNTQxMzEyNTQ1MzkyNTQxNDEyNTM4NDMyNTQ1MzYyNTQyMzUyNTM4MzEyNTQ1MzcyNTQxMzgyNTM4NDIyZTcwNmU2Ny5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f56312545362541302541312545392541412538432545362542352538312545372541382538422e706e67"></p>
<p>若中间任何一步校验失败，APK就不能安装。</p>
<p>OK，了解了V1的签名和校验流程。我们来看下，V1签名是怎么保证APK文件不被篡改的？ 首先，如果破坏者修改了APK中的任何文件，那么被篡改文件的数据摘要的Base64编码就和<code>MANIFEST.MF</code>文件的记录值不一致，导致校验失败。 其次，如果破坏者同时修改了对应文件在<code>MANIFEST.MF</code>文件中的Base64值，那么MANIFEST.MF中对应数据块的Base64值就和<code>CERT.SF</code>文件中的记录值不一致，导致校验失败。 最后，如果破坏者更进一步，同时修改了对应文件在<code>CERT.SF</code>文件中的Base64值，那么<code>CERT.SF</code>的数字签名就和<code>CERT.RSA</code>记录的签名不一致，也会校验失败。 那有没有可能继续伪造<code>CERT.SF</code>的数字签名那？理论上不可能，因为破坏者没有开发者的私钥。那破坏者是不是可以用自己的私钥和数字证书重新签名那，这倒是完全可以！</p>
<p>综上所述，任何对APK文件的修改，在安装时都会失败，除非对APK重新签名。但是相同包名，不同签名的APK也是不能同时安装的。</p>
<h4 id="APK-签名方案-v2（v2-方案）"><a href="#APK-签名方案-v2（v2-方案）" class="headerlink" title="APK 签名方案 v2（v2 方案）"></a>APK 签名方案 v2（v2 方案）</h4><h5 id="为什么需要V2签名"><a href="#为什么需要V2签名" class="headerlink" title="为什么需要V2签名"></a>为什么需要V2签名</h5><p>从前面的V1签名介绍，可以知道V1存在两个弊端：</p>
<ol>
<li><code>MANIFEST.MF</code>中的数据摘要是基于原始未压缩文件计算的。因此在校验时，需要先解压出原始文件，才能进行校验。而解压操作无疑是耗时的。</li>
<li>V1签名仅仅校验APK第一部分中的文件，缺少对APK的完整性校验。因此，在签名后，我们还可以修改APK文件，例如：通过zipalign进行字节对齐后，仍然可以正常安装。</li>
</ol>
<p>正是基于这两点，Google提出了V2签名，解决了上述两个问题：</p>
<ol>
<li>V2签名是对APK本身进行数据摘要计算，不存在解压APK的操作，减少了校验时间。</li>
<li>V2签名是针对整个APK进行校验（不包含签名块本身），因此对APK的任何修改（包括添加注释、zipalign字节对齐）都无法通过V2签名的校验。</li>
</ol>
<p>关于第一点的耗时问题，这里有一份实验室数据（Nexus 6P、Android 7.1.1）可供参考。 </p>
<table>
<thead>
<tr>
<th style="text-align:center">APK安装耗时对比</th>
<th style="text-align:center">取5次平均耗时（秒）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V1签名APK</td>
<td style="text-align:center">11.64</td>
</tr>
<tr>
<td style="text-align:center">V2签名APK</td>
<td style="text-align:center">4.42</td>
</tr>
</tbody>
</table>
<p>可见，V2签名对APK的安装速度还是提升不少的。 </p>
<p>​        Android 7.0 中引入了 APK 签名方案 v2（v2 方案）。该方案会对 APK 的内容进行哈希处理和签名，然后将生成的“APK 签名分块”插入到 APK 中。如要详细了解如何在应用中使用 v2 方案，请参阅 Android N 开发者预览版中的 <a href="https://developer.android.com/about/versions/nougat/android-7.0.html#apk_signature_v2" target="_blank" rel="noopener">APK 签名方案 v2</a>。</p>
<p>在验证期间，v2 方案会将 APK 文件视为 Blob，并对整个文件进行签名检查。对 APK 进行的任何修改（包括对 ZIP 元数据进行的修改）都会使 APK 签名作废。这种形式的 APK 验证不仅速度要快得多，而且能够发现更多种未经授权的修改。</p>
<p>新的签名格式向后兼容，因此，使用这种新格式签名的 APK 可在更低版本的 Android 设备上进行安装（会直接忽略添加到 APK 的额外数据），但前提是这些 APK 还带有 v1 签名。</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234550495-YXBrLXZhbGlkYXRpb24tcHJvY2Vzcy5wbmc=.png" alt="apk-validation-process"></p>
<p>APK 签名验证过程（新步骤以红色显示） </p>
<p>验证程序会对照存储在“APK 签名分块”中的 v2 签名对 APK 的全文件哈希进行验证。该哈希涵盖除“APK 签名分块”（其中包含 v2 签名）之外的所有内容。在“APK 签名分块”以外对 APK 进行的任何修改都会使 APK 的 v2 签名作废。v2 签名被删除的 APK 也会被拒绝，因为 v1 签名指明相应 APK 带有 v2 签名，所以 Android Nougat 及更高版本会拒绝使用 v1 签名验证 APK。 </p>
<h5 id="V2签名机制"><a href="#V2签名机制" class="headerlink" title="V2签名机制"></a>V2签名机制</h5><p>不同于V1，V2签名会生成一个签名块，插入到APK中。因此，V2签名后的APK结构如下图所示： </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234613182-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU2MzIyNTQ1MzcyNTQxNDQyNTQyNDUyNTQ1MzUyNTM5MzAyNTM4NDQyNTQ1MzUyNTM5MzAyNTM4NDUyNTQ1MzcyNTM5NDEyNTM4MzQ0MTUwNGIyZTcwNmU2Ny5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f563225453725414425424525453525393025384425453525393025384525453725394125383441504b2e706e67"></p>
<p>APK签名块位于中央目录之前，文件数据之后。<strong>V2签名同时修改了EOCD中的中央目录的偏移量，使签名后的APK还符合ZIP结构</strong>。 </p>
<p>APK签名块的具体结构如下图所示： </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234613182-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU2MzIyNTQ1MzcyNTQxNDQyNTQyNDUyNTQ1MzUyNTM5MzAyNTM4NDQyNTQ1MzUyNTM5MzAyNTM4NDUyNTQ1MzcyNTM5NDEyNTM4MzQ0MTUwNGIyZTcwNmU2Ny5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f563225453725414425424525453525393025384425453525393025384525453725394125383441504b2e706e67"></p>
<p>首先是8字节的签名块大小，此大小不包含该字段本身的8字节；其次就是ID-Value序列，就是一个4字节的ID和对应的数据；然后又是一个8字节的签名块大小，与开始的8字节是相等的；最后是16字节的签名块魔数。 其中，<strong>ID为0x7109871a对应的Value就是V2签名块数据</strong>。</p>
<p>V2签名块的生成可参考<a href="https://android.googlesource.com/platform/build/+/dd910c5/tools/signapk/src/com/android/signapk/ApkSignerV2.java" target="_blank" rel="noopener">ApkSignerV2</a>，整体结构和流程如下图所示：</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234697567-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU2MzIyNTQ1MzcyNTQxNDQyNTQyNDUyNTQ1MzUyNTM5MzAyNTM4NDQyNTQ1MzUyNTM5NDQyNTM5MzcyNTQ1MzcyNTM5MzQyNTM5NDYyNTQ1MzYyNTM4MzgyNTM5MzAyNTQ1MzYyNTQyMzUyNTM4MzEyNTQ1MzcyNTQxMzgyNTM4NDIyZS5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f56322545372541442542452545352539302538442545352539442539372545372539342539462545362538382539302545362542352538312545372541382538422e"></p>
<p>首先，根据多个签名算法，计算出整个APK的数据摘要，组成左上角的<strong>APK数据摘要集</strong>； 接着，把最左侧一列的<code>数据摘要</code>、<code>数字证书</code>和<code>额外属性</code>组装起来，形成类似于V1签名的“MF”文件（第二列第一行）； 其次，再用相同的私钥，不同的签名算法，计算出“MF”文件的数字签名，形成类似于V1签名的“SF”文件（第二列第二行）； 然后，把第二列的<code>类似MF文件</code>、<code>类似SF文件</code>和<code>开发者公钥</code>一起组装成通过单个keystore签名后的v2签名块（第三列第一行）。 最后，把多个keystore签名后的签名块组装起来，就是完整的V2签名块了（Android中允许使用多个keystore对apk进行签名）。</p>
<p>上述流程比较繁琐。简而言之，单个keystore签名块主要由三部分组成，分别是上图中第二列的三个数据块：<code>类似MF文件</code>、<code>类似SF文件</code>和<code>开发者公钥</code>，其结构如下图所示：</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234722431-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjc2MzIyNTQ1MzcyNTQxNDQyNTQyNDUyNTQ1MzUyNTM5MzAyNTM4NDQyNTQ1MzUyNTM5NDQyNTM5MzcyNTQ1MzcyNTQyNDIyNTM5MzMyNTQ1MzYyNTM5NDUyNTM4MzQyZTcwNmU2Ny5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f76322545372541442542452545352539302538442545352539442539372545372542422539332545362539452538342e706e67"></p>
<p>除此之外，Google也优化了计算数据摘要的算法，使得可以并行计算，如下图所示： </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234748668-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU2MzIyNTQ1MzYyNTM5MzUyNTQyMzAyNTQ1MzYyNTM4NDQyNTQxNDUyNTQ1MzYyNTM5MzEyNTM5MzgyNTQ1MzgyNTQxMzYyNTM4MzEyNTQ1MzcyNTQxNDUyNTM5MzcyNTQ1MzYyNTQyMzMyNTM5MzUyZTcwNmU2Ny5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f56322545362539352542302545362538442541452545362539312539382545382541362538312545372541452539372545362542332539352e706e67"></p>
<p>数据摘要的计算包括以下几步：</p>
<ol>
<li>首先，将上述APK中文件内容块、中央目录、EOCD按照1MB大小分割成一些小块。</li>
<li>然后，计算每个小块的数据摘要，基础数据是0xa5 + 块字节长度 + 块内容。</li>
<li>最后，计算整体的数据摘要，基础数据是0x5a + 数据块的数量 + 每个数据块的摘要内容。</li>
</ol>
<p>这样，每个数据块的数据摘要就可以并行计算，加快了V2签名和校验的速度。  </p>
<h5 id="V2校验流程"><a href="#V2校验流程" class="headerlink" title="V2校验流程"></a>V2校验流程</h5><p>Android Gradle Plugin2.2之上默认会同时开启V1和V2签名，同时包含V1和V2签名的<code>CERT.SF</code>文件会有一个特殊的主属性，如下图所示： </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234767461-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjU4MmQ0MTZlNjQ3MjZmNjk2NDJkNDE1MDRiMmQ1MzY5Njc2ZTY1NjQyZTcwNmU2Ny5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f582d416e64726f69642d41504b2d5369676e65642e706e67">                </p>
<p>该属性会强制APK走V2校验流程（7.0之上），以充分利用V2签名的优势（速度快和更完善的校验机制）。 因此，同时包含V1和V2签名的APK的校验流程如下所示：  </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234786132-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjI1NDUzNjI1NDEzMDI1NDEzMTI1NDUzOTI1NDE0MTI1Mzg0MzI1NDUzOTI1MzgzMDI1MzgzOTI1NDUzNjI1Mzg0MjI1NDEzOTJlNzA2ZTY3LnBuZw==.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f2545362541302541312545392541412538432545392538302538392545362538422541392e706e67"></p>
<p>简而言之：优先校验V2，没有或者不认识V2，则校验V1。</p>
<p>这里引申出另外一个问题：APK签名时，只有V2签名，没有V1签名行不行？ 经过尝试，这种情况是可以编译通过的，并且在Android 7.0之上也可以正确安装和运行。但是7.0之下，因为不认识V2，又没有V1签名，所以会报没有签名的错误。</p>
<hr>
<p>OK，明确了Android平台对V1和V2签名的校验选择之后，我们来看下V2签名的具体校验流程（<code>PackageManagerService.java</code> -&gt; <code>PackageParser.java</code> -&gt; <code>ApkSignatureSchemeV2Verifier.java</code>），如下图所示： </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234804343-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjc2MzIyNTQ1MzYyNTQxMzAyNTQxMzEyNTQ1MzkyNTQxNDEyNTM4NDMyNTQ1MzYyNTQyMzUyNTM4MzEyNTQ1MzcyNTQxMzgyNTM4NDIyZTcwNmU2Ny5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f76322545362541302541312545392541412538432545362542352538312545372541382538422e706e67"></p>
<p>其中，最强签名算法是根据该算法使用的数据摘要算法来对比产生的，比如：SHA512 &gt; SHA256。 校验成功的定义是至少找到一个keystore对应的签名块，并且所有签名块都按照上述流程校验成功。</p>
<p>下面我们来看下V2签名是怎么保证APK不被篡改的？ 首先，如果破坏者修改了APK文件的任何部分（签名块本身除外），那么APK的数据摘要就和“MF”数据块中记录的数据摘要不一致，导致校验失败。 其次，如果破坏者同时修改了“MF”数据块中的数据摘要，那么“MF”数据块的数字签名就和“SF”数据块中记录的数字签名不一致，导致校验失败。 然后，如果破坏者使用自己的私钥去加密生成“SF”数据块，那么使用开发者的公钥去解密“SF”数据块中的数字签名就会失败； 最后，更进一步，若破坏者甚至替换了开发者公钥，那么使用数字证书中的公钥校验签名块中的公钥就会失败，这也正是数字证书的作用。</p>
<p>综上所述，任何对APK的修改，在安装时都会失败，除非对APK重新签名。但是相同包名，不同签名的APK也是不能同时安装的。</p>
<hr>
<p>到这里，V2签名已经介绍完了。但是在最后一步“数据摘要校验”这里，隐藏了一个点，不知道有没有人发现？ 因为，我们V2签名块中的数据摘要是针对APK的文件内容块、中央目录和EOCD三块内容计算的。但是在写入签名块后，修改了EOCD中的中央目录偏移量，那么在进行V2签名校验时，理论上在“数据摘要校验”这步应该会校验失败啊！但是为什么V2签名可以校验通过那？</p>
<p>这个问题很重要，因为我们下面要介绍的<strong>基于V2签名的多渠道打包方案</strong>也会修改EOCD的中央目录偏移量。</p>
<p>其实也很简单，原来Android系统在校验APK的数据摘要时，首先会把EOCD的中央目录偏移量替换成签名块的偏移量，然后再计算数据摘要。而签名块的偏移量不就是v2签名之前的中央目录偏移量嘛！！！，因此，这样计算出的数据摘要就和“MF”数据块中的数据摘要完全一致了。具体代码逻辑，可参考<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/util/apk/ApkSignatureSchemeV2Verifier.java" target="_blank" rel="noopener">ApkSignatureSchemeV2Verifier.java</a>的416 ~ 420行。</p>
<p>​                                                                                                            来源于<a href="https://source.android.com/security/apksigning/" target="_blank" rel="noopener">Android安全性</a>或者<a href="https://github.com/Tencent/VasDolly/wiki/VasDolly%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">VasDolly</a></p>
<h2 id="VasDolly多渠道原理"><a href="#VasDolly多渠道原理" class="headerlink" title="VasDolly多渠道原理"></a>VasDolly多渠道原理</h2><h3 id="V1多渠道原理"><a href="#V1多渠道原理" class="headerlink" title="V1多渠道原理"></a>V1多渠道原理</h3><p>由V1签名和校验机制可知，修改APK中的任何文件都会导致安装失败！那怎么添加渠道信息那？只能从APK的结构入手了。 </p>
<p>APK文件本质上是一个ZIP压缩包，而ZIP格式是固定的，主要由三部分构成，如下图所示： </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234831308-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjQxNTA0YjI1NDUzNjI1MzkzNjI1MzgzNzI1NDUzNDI1NDI0MjI1NDIzNjI1NDUzNzI1NDI0MjI1MzkzMzI1NDUzNjI1Mzk0NTI1MzgzNDJlNzA2ZTY3LnBuZw==.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f41504b2545362539362538372545342542422542362545372542422539332545362539452538342e706e67"></p>
<p>第一部分是内容块，所有的压缩文件都在这部分。每个压缩文件都有一个<code>local file header</code>，主要记录了文件名、压缩算法、压缩前后的文件大小、修改时间、CRC32值等。 第二部分称为中央目录，包含了多个<code>central directory file header</code>（和第一部分的<code>local file header</code>一一对应），每个中央目录文件头主要记录了压缩算法、注释信息、对应<code>local file header</code>的偏移量等，方便快速定位数据。 最后一部分是EOCD，主要记录了中央目录大小、偏移量和ZIP注释信息等，其详细结构如下图所示： </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234850973-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjQ1NGY0MzQ0MmU3MDZlNjcucG5n.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f454f43442e706e67"></p>
<p>根据之前的V1签名和校验机制可知，V1签名只会检验第一部分的所有压缩文件，而不理会后两部分内容。因此，只要把渠道信息写入到后两块内容就可以通过V1校验，而EOCD的注释字段无疑是最好的选择。 </p>
<p>既然找到了突破口，那么基于V1签名的多渠道打包方案就应运而生：<strong>在APK文件的注释字段，添加渠道信息</strong>。 整个方案包括以下几步： </p>
<ol>
<li><p>复制APK</p>
</li>
<li><p>找到EOCD数据块</p>
</li>
<li><p>修改注释长度</p>
</li>
<li><p>添加渠道信息</p>
</li>
<li><p>添加渠道信息长度</p>
</li>
<li><p>添加魔数</p>
</li>
</ol>
<p>添加渠道信息后的EOCD数据块如下所示： </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234870776-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjI1NDUzNjI1NDIzNzI1NDI0MjI1NDUzNTI1Mzg0MTI1NDEzMDI1NDUzNjI1NDIzODI1NDEzMDI1NDUzOTI1MzgzMTI1MzkzMzI1NDUzNDI1NDI0NjI1NDEzMTI1NDUzNjI1MzgzMTI1NDE0NjI1NDUzNTI1MzkzMDI1Mzg0NTI1NDUzNzI1My5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f254536254237254242254535253841254130254536254238254130254539253831253933254534254246254131254536253831254146254535253930253845254537253"></p>
<p>这里添加魔数的好处是方便从后向前读取数据，定位渠道信息。 因此，读取渠道信息包括以下几步：</p>
<ol>
<li>定位到魔数</li>
<li>向前读两个字节，确定渠道信息的长度LEN</li>
<li>继续向前读LEN字节，就是渠道信息了。</li>
</ol>
<p>通过16进制编辑器，可以查看到添加渠道信息后的APK（小端模式），如下所示：</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234891952-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjI1NDUzNjI1NDIzNzI1NDI0MjI1NDUzNTI1Mzg0MTI1NDEzMDI1NDUzNjI1NDIzODI1NDEzMDI1NDUzOTI1MzgzMTI1MzkzMzI1NDUzNTI1MzkzMDI1Mzg0NTI1NDUzNzI1Mzk0MTI1MzgzNDQxNTA0YjJkNTYzMTJkNmU2NTc3MmU3MDZlNi5wbmc=.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f25453625423725424225453525384125413025453625423825413025453925383125393325453525393025384525453725394125383441504b2d56312d6e65772e706e6"></p>
<p><code>6C 74 6C 6F 76 75 7A 68</code>是魔数，<code>04 00</code>表示渠道信息长度为4，<code>6C 65 6F 6E</code>就是渠道信息<code>leon</code>了。<code>0E 00</code>就是APK注释长度了，正好是15。 </p>
<p>虽说整个方案很清晰，但是在<code>找到EOCD数据块</code>这步遇到一个问题。如果APK本身没有注释，那最后22字节就是EOCD。但是若APK本身已经包含了注释字段，那怎么确定EOCD的起始位置那？这里借鉴了系统V2签名确定EOCD位置的方案。整个计算流程如下图所示： </p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234914283-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjI1NDUzNzI1NDEzMTI1NDE0NTI1NDUzNTI1NDE0NTI1Mzk0MTQ1NGY0MzQ0MjU0NTM3MjUzOTQxMjUzODM0MjU0NTM0MjU0MjQ0MjUzODQ0MjU0NTM3MjU0MjQ0MjU0MTQ1MmU3MDZlNjcucG5n.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f254537254131254145254535254145253941454f43442545372539412538342545342542442538442545372542442541452e706e67"></p>
<p>整个方案介绍完了，该方案的最大优点就是：不需要解压缩APK，不需要重新签名，只需要复制APK，在注释字段添加渠道信息。每个渠道包仅需几秒的耗时，非常适合渠道较多的APK。</p>
<p>但是好景不长，Android7.0之后新增了V2签名，该签名会校验整个APK的数据摘要，导致上述渠道打包方案失效。所以如果想继续使用上述方案，需要关闭Gradle Plugin中的V2签名选项，禁用V2签名。</p>
<h3 id="V2多渠道原理"><a href="#V2多渠道原理" class="headerlink" title="V2多渠道原理"></a>V2多渠道原理</h3><p>在V2签名的校验流程中，有一个很重要的细节：<strong>Android系统只会关注ID为0x7109871a的V2签名块，并且忽略其他的ID-Value，同时V2签名只会保护APK本身，不包含签名块</strong>。 </p>
<p>因此，基于V2签名的多渠道打包方案就应运而生：<strong>在APK签名块中添加一个ID-Value，存储渠道信息</strong>。 整个方案包括以下几步： </p>
<ol>
<li>找到APK的EOCD块</li>
<li>找到APK签名块</li>
<li>获取已有的ID-Value Pair</li>
<li>添加包含渠道信息的ID-Value</li>
<li>基于所有的ID-Value生成新的签名块</li>
<li>修改EOCD的中央目录的偏移量（上面已介绍过：修改EOCD的中央目录偏移量，不会导致数据摘要校验失败）</li>
<li>用新的签名块替代旧的签名块，生成带有渠道信息的APK</li>
</ol>
<p>实际上，除了渠道信息，我们可以在APK签名块中添加任何辅助信息。</p>
<p>通过16进制编辑器，可以查看到添加渠道信息后的APK（小端模式），如下所示：</p>
<p><img src="https://ojlty2hua.qnssl.com/image-1527234942589-Njg3NDc0NzAzYTJmMmYzNzc4NzMzMjcxNzkyZTYzNmY2ZDMxMmU3YTMwMmU2NzZjNjIyZTYzNmM2Zjc1NjQ2NDZlMmU2MzZmNmQyZjI1NDUzNjI1NDIzNzI1NDI0MjI1NDUzNTI1Mzg0MTI1NDEzMDI1NDUzNjI1NDIzODI1NDEzMDI1NDUzOTI1MzgzMTI1MzkzMzI1NDUzNTI1MzkzMDI1Mzg0NTI1NDUzNzI1Mzk0MTI1MzgzNDQxNTA0YjJkNTYzMjJlNzA2ZTY3LnBuZw==.png" alt="687474703a2f2f3778733271792e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f25453625423725424225453525384125413025453625423825413025453925383125393325453525393025384525453725394125383441504b2d56322e706e67"></p>
<p><code>6C 65 6F 6E</code>就是我们的渠道信息<code>leon</code>。向前4个字节：<code>FF 55 11 88</code>就是我们添加的ID，再向前8个字节：<code>08 00 00 00 00 00 00 00</code>就是我们的ID-Value的长度，正好是8。 </p>
<p>整个方案介绍完了，该方案的最大优点就是：支持7.0之上新增的V2签名，同时兼有V1方案的所有优点。 </p>
<h3 id="多渠道包的强校验"><a href="#多渠道包的强校验" class="headerlink" title="多渠道包的强校验"></a>多渠道包的强校验</h3><p>那么如何保证通过这些方案生成的渠道包，能够在所有Android平台上正确安装那？</p>
<p>原来Google提供了一个同时支持V1和V2签名和校验的工具：<a href="https://android.googlesource.com/platform/tools/apksig" target="_blank" rel="noopener">apksig</a>。它包括一个<code>apksigner</code>命令行和一个<code>apksig</code>类库。其中前者就是Android SDK build-tools下面的命令行工具。而我们正是借助后面的apksig来进行渠道包强校验，它可以保证渠道包在apk Minsdk ~ 最高版本之间都校验通过。</p>
<h3 id="多渠道打包工具对比"><a href="#多渠道打包工具对比" class="headerlink" title="多渠道打包工具对比"></a>多渠道打包工具对比</h3><p>目前市面上的多渠道打包工具主要有<a href="https://github.com/mcxiaoke/packer-ng-plugin" target="_blank" rel="noopener">packer-ng-plugin</a>和美团的<a href="https://github.com/Meituan-Dianping/walle" target="_blank" rel="noopener">Walle</a>。下表是我们的<a href="https://github.com/Tencent/VasDolly" target="_blank" rel="noopener">VasDolly</a>和它们之间的简单对比。 </p>
<table>
<thead>
<tr>
<th style="text-align:center">多渠道打包工具对比</th>
<th style="text-align:center">VasDolly</th>
<th style="text-align:center">packer-ng-plugin</th>
<th style="text-align:center">Walle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V1签名方案</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">V2签名方案</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">已有注释块的APK</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">根据已有APK生成渠道包</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">命令行工具</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">强校验</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">多线程加速打包</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不支持</td>
</tr>
</tbody>
</table>
<p>这里我之所以同时支持V1和V2签名方案，主要是担心后续Android平台加强签名校验机制，导致V2多渠道打包方案行不通，可以无痛切换到V1签名方案。 </p>
<p><strong>缺点:</strong> 不能对APK打包定制化，比如指定myapp的渠道名字为”新闻测试”等</p>
<p><strong>总结</strong> </p>
<p>​       优点大于缺点,使用VasDolly打包比之前多渠道打包节省时间高达95%,达到了节省时间,提高效率目标.</p>
<p>测试修改记录</p>
<p><strong>2018.5</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
      
      

      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">MuFeiXue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何产生这种需求"><span class="nav-number">1.</span> <span class="nav-text">如何产生这种需求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#了解Android安装包-APK-的构成"><span class="nav-number">2.</span> <span class="nav-text">了解Android安装包(.APK)的构成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#apk是什么"><span class="nav-number">2.1.</span> <span class="nav-text">apk是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apk的结构"><span class="nav-number">2.2.</span> <span class="nav-text">apk的结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#了解数据摘要、数字签名和数字证书"><span class="nav-number">3.</span> <span class="nav-text">了解数据摘要、数字签名和数字证书</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据摘要"><span class="nav-number">3.1.</span> <span class="nav-text">数据摘要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数字签名和数字证书"><span class="nav-number">3.2.</span> <span class="nav-text">数字签名和数字证书</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#了解V1和V2"><span class="nav-number">4.</span> <span class="nav-text">了解V1和V2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#APK-签名方案"><span class="nav-number">4.1.</span> <span class="nav-text">APK 签名方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JAR-签名（v1-方案）"><span class="nav-number">4.1.1.</span> <span class="nav-text">JAR 签名（v1 方案）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#V1签名机制"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">V1签名机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#V1校验流程"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">V1校验流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#APK-签名方案-v2（v2-方案）"><span class="nav-number">4.1.2.</span> <span class="nav-text">APK 签名方案 v2（v2 方案）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么需要V2签名"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">为什么需要V2签名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#V2签名机制"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">V2签名机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#V2校验流程"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">V2校验流程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VasDolly多渠道原理"><span class="nav-number">5.</span> <span class="nav-text">VasDolly多渠道原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#V1多渠道原理"><span class="nav-number">5.1.</span> <span class="nav-text">V1多渠道原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#V2多渠道原理"><span class="nav-number">5.2.</span> <span class="nav-text">V2多渠道原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多渠道包的强校验"><span class="nav-number">5.3.</span> <span class="nav-text">多渠道包的强校验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多渠道打包工具对比"><span class="nav-number">5.4.</span> <span class="nav-text">多渠道打包工具对比</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MuFeiXue</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

 
</body>
</html>
